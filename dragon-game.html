<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rainforest Frog Flight</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #1e355f, #050814);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    #game-wrapper {
      position: relative;
    }

    canvas {
      border-radius: 8px;
      background: linear-gradient(to top, #2c4c1e, #1c2340);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      display: block;
    }

    #hud {
      position: absolute;
      top: 8px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7);
      pointer-events: none;
    }

    #controls {
      position: absolute;
      bottom: 8px;
      left: 12px;
      right: 12px;
      font-size: 13px;
      opacity: 0.8;
      text-align: center;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.7);
      pointer-events: none;
    }

    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      font-size: 20px;
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.8);
      pointer-events: none;
    }

    #message.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div id="game-wrapper">
    <canvas id="game" width="800" height="400"></canvas>
    <div id="hud">
      <div>üê∏ Rainforest Flight</div>
      <div>Score: <span id="score">0</span></div>
    </div>
    <div id="controls">
      Press <strong>Space</strong> or <strong>‚Üë</strong> to flap &nbsp;|&nbsp;
      Press <strong>Enter</strong> to restart after crashing
    </div>
    <div id="message" class="hidden"></div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    /** @type {CanvasRenderingContext2D} */
    const ctx = canvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const messageEl = document.getElementById("message");

    const WIDTH = canvas.width;
    const HEIGHT = canvas.height;

    // Game state
    let dragon;
    let obstacles;
    let gravity;
    let gameSpeed;
    let frameCount;
    let score;
    let isGameOver;
    let backgroundOffset;
    let backgroundTrees;
    let backgroundFlowers;

    // Dragon (frog) constants
    const DRAGON_WIDTH = 50;
    const DRAGON_HEIGHT = 35;

    // Obstacle constants
    const OBSTACLE_WIDTH = 70;
    const GAP_HEIGHT = 200;
    const OBSTACLE_SPACING_MIN = 90; // frames between spawns (min)
    const OBSTACLE_SPACING_MAX = 140; // frames between spawns (max)

    let nextObstacleIn = 0;

    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function resetGame() {
      dragon = {
        x: 140,
        y: HEIGHT / 2,
        width: DRAGON_WIDTH,
        height: DRAGON_HEIGHT,
        dy: 0,
        flapStrength: -8
      };

      gravity = 0.4;
      gameSpeed = 3.5;
      frameCount = 0;
      score = 0;
      obstacles = [];
      isGameOver = false;
      nextObstacleIn = Math.floor(randomRange(OBSTACLE_SPACING_MIN, OBSTACLE_SPACING_MAX));
      backgroundOffset = 0;
      backgroundTrees = [];
      backgroundFlowers = [];
      generateBackgroundDecorations();
      scoreEl.textContent = "0";

      messageEl.textContent = "";
      messageEl.classList.add("hidden");
    }

    function generateBackgroundDecorations() {
      // Precompute tree and flower positions so the scenery does not jitter
      for (let x = 40; x < WIDTH + 200; x += 140) {
        backgroundTrees.push({
          x,
          trunkHeight: randomRange(150, 240),
          canopyLift: randomRange(18, 32)
        });
      }

      for (let x = 20; x < WIDTH + 200; x += 90) {
        backgroundFlowers.push({
          x,
          y: HEIGHT - 60 + randomRange(-6, -1)
        });
      }
    }

    function spawnObstacle() {
      const margin = 40;
      const maxGapTop = HEIGHT - GAP_HEIGHT - margin;
      const gapTop = randomRange(margin, maxGapTop);

      obstacles.push({
        x: WIDTH + 20,
        width: OBSTACLE_WIDTH,
        gapTop: gapTop,
        gapBottom: gapTop + GAP_HEIGHT,
        scored: false
      });
    }

    function updateDragon() {
      // Apply gravity
      dragon.dy += gravity;
      dragon.y += dragon.dy;

      // Check top and bottom bounds (crash if outside)
      if (dragon.y + dragon.height > HEIGHT || dragon.y < 0) {
        triggerGameOver();
      }
    }

    function updateObstacles() {
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const ob = obstacles[i];
        ob.x -= gameSpeed;

        // Score when passing obstacle
        if (!ob.scored && ob.x + ob.width < dragon.x) {
          ob.scored = true;
          score += 1;
          scoreEl.textContent = String(score);
        }

        // Remove off-screen obstacles
        if (ob.x + ob.width < 0) {
          obstacles.splice(i, 1);
        }
      }

      // Handle spawning timing
      nextObstacleIn -= 1;
      if (nextObstacleIn <= 0) {
        spawnObstacle();
        nextObstacleIn = Math.floor(
          randomRange(OBSTACLE_SPACING_MIN, OBSTACLE_SPACING_MAX)
        );
      }
    }

    function checkCollisions() {
      for (const ob of obstacles) {
        const dragonRight = dragon.x + dragon.width;
        const dragonBottom = dragon.y + dragon.height;

        const horizontallyOverlapping =
          dragonRight > ob.x && dragon.x < ob.x + ob.width;

        if (horizontallyOverlapping) {
          const hitsTop = dragon.y < ob.gapTop;
          const hitsBottom = dragonBottom > ob.gapBottom;

          if (hitsTop || hitsBottom) {
            triggerGameOver();
            return;
          }
        }
      }
    }

    function triggerGameOver() {
      if (isGameOver) return;
      isGameOver = true;
      messageEl.innerHTML =
        `üí• Game Over!<br/>Score: <strong>${score}</strong><br/><br/>Press <strong>Enter</strong> or <strong>Space</strong> to play again.`;
      messageEl.classList.remove("hidden");
    }

    function drawBackground() {
      // Ground
      const groundHeight = 60;
      const offset = backgroundOffset % WIDTH;

      // Shift the scenery to create a scrolling effect
      ctx.save();
      ctx.translate(-offset, 0);

      // Draw two tiles so we always cover the canvas while scrolling
      for (let i = -WIDTH; i <= WIDTH; i += WIDTH) {
        ctx.save();
        ctx.translate(i, 0);

        // Vibrant jungle floor
        ctx.fillStyle = "#2d5d32";
        ctx.fillRect(0, HEIGHT - groundHeight, WIDTH, groundHeight);

        // Tree trunks and canopies (precomputed so they stay steady)
        const trunkWidth = 24;
        for (const tree of backgroundTrees) {
          const baseX = tree.x;
          const trunkTopY = HEIGHT - groundHeight - tree.trunkHeight;

          ctx.fillStyle = "#3b2a18";
          ctx.fillRect(baseX, trunkTopY, trunkWidth, tree.trunkHeight);

          const canopyCenterY = trunkTopY - tree.canopyLift;
          const canopyCenterX = baseX + trunkWidth / 2;

          ctx.fillStyle = "#3fa35b";
          ctx.beginPath();
          ctx.ellipse(canopyCenterX, canopyCenterY, 70, 40, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(canopyCenterX + 55, canopyCenterY + 10, 60, 35, 0, 0, Math.PI * 2);
          ctx.fill();
        }

        // Flowers (precomputed so they don't jitter)
        for (const flower of backgroundFlowers) {
          ctx.fillStyle = "#f9c74f";
          ctx.beginPath();
          ctx.arc(flower.x, flower.y, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#ff6f61";
          ctx.beginPath();
          ctx.arc(flower.x + 8, flower.y + 2, 3, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.restore();
      }

      ctx.restore();
    }

    function drawDragon() {
      // Render a big poison-dart frog emoji as the player character
      ctx.save();
      ctx.translate(dragon.x, dragon.y);
      ctx.font = "48px 'Apple Color Emoji', 'Segoe UI Emoji', sans-serif";
      ctx.fillText("üê∏", -6, 40);
      ctx.restore();
    }

    function drawObstacles() {
      for (const ob of obstacles) {
        // Top log
        ctx.fillStyle = "#4b2e16";
        ctx.fillRect(ob.x, 0, ob.width, ob.gapTop);

        // Bottom log
        ctx.fillRect(ob.x, ob.gapBottom, ob.width, HEIGHT - ob.gapBottom);

        // Bark highlight
        ctx.fillStyle = "#6d4c33";
        ctx.fillRect(ob.x, ob.gapTop - 6, ob.width, 6);
        ctx.fillRect(ob.x, ob.gapBottom, ob.width, 6);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      drawBackground();
      drawObstacles();
      drawDragon();
    }

    function update() {
      if (isGameOver) return;
      frameCount += 1;
      updateDragon();
      updateObstacles();
      checkCollisions();

      // Scroll background slower than obstacles for parallax feel
      backgroundOffset = (backgroundOffset + gameSpeed * 0.6) % WIDTH;

      // Slight difficulty scaling
      if (frameCount % 600 === 0) {
        gameSpeed += 0.3;
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Input handling
    function handleFlap() {
      if (isGameOver) {
        resetGame();
        return;
      }
      dragon.dy = dragon.flapStrength;
    }

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space" || e.code === "ArrowUp") {
        e.preventDefault();
        handleFlap();
      } else if (e.code === "Enter" && isGameOver) {
        e.preventDefault();
        resetGame();
      }
    });

    // Start game
    resetGame();
    gameLoop();
  </script>
</body>
</html>
